## CSharp
# 第一次作业概述
- 老师您好，我是周嘉伟

     由于我本科完全没有接触过相关程序设计，能力有限。
     因此本次作业只能尽力完成了实现输出最长公共子序列功能的程序。
     您展示的输出序列前面加+、-号的功能与泛型都没有实现。望老师包涵。
     接下来谈一谈对LCS算法的理解。
     
# LCS算法理解
- LCS算法的功能
     
     LCS算法的功能是找出两个序列的最长公共子序列。即找出两个序列中最
     多的相同元素（顺序也得一样）。
     

- LCS算法需要解决的问题

  首先我们先自定义两个序列X、Y。
  其次假定序列Z=﹤z1，⋯，zk﹥∈LCS(X , Y)。
  
  紧接着我们开始讨论一下几种情况：
  
  1. xm=yn（最后一个字符相同）  
  
        若最后一个字符相同，不难用反证法证明：
        该字符必是X与Y的任一最长公共子序列Z（设长度为k）
        的最后一个字符，即有zk = xm = yn 且显然有Zk-1∈
        LCS(Xm-1 , Yn-1)即Z的前缀Zk-1是Xm-1与Yn-1的最
        长公共子序列。此时，问题变成求Xm-1与Yn-1的LCS
       （LCS(X , Y)的长度等于LCS(Xm-1 , Yn-1)的长度加1）。
  2. xm≠yn
  
        若最后一个字符不相同，还可以用反证法证明：
        要么Z∈LCS(Xm-1, Y)，要么Z∈LCS(X , Yn-1)。
        由于zk≠xm与zk≠yn其中至少有一个必成立，
        若zk≠xm则有Z∈LCS(Xm-1 , Y)，类似的，若zk≠yn
        则有Z∈LCS(X , Yn-1)。此时，问题变成求Xm-1与Y的LCS
        及X与Yn-1的LCS。LCS(X , Y)的长度为：max{LCS(Xm-1 , Y)的
        长度, LCS(X , Yn-1)的长度}。
  
   综上，解决LCS问题要求三个方面的东西：
   
   1、LCS（Xm-1，Yn-1）+1；
   
   2、LCS（Xm-1，Y），LCS（X，Yn-1）；
   
   3、max{LCS（Xm-1，Y），LCS（X，Yn-1）}。
   
   #LCS算法的实现
   - 计算序列X、Y的最长公共子序列的长度
   
      要找出X=<x1, x2, …, xm>和Y=<y1, y2, …, yn>的最长公共子序列，可按以下方式递归地进行：
      当xm=yn时，找出Xm-1和Yn-1的最长公共子序列，然后在其尾部加上xm(=yn)即可得X和Y的一个最长
      公共子序列。当xm≠yn时，必须解两个子问题，即找出Xm-1和Y的一个最长公共子序列及X和Yn-1的
      一个最长公共子序列。这两个公共子序列中较长者即为X和Y的一个最长公共子序列。
     
     由此递归结构容易看到最长公共子序列问题具有子问题重叠性质。例如，在计算X和Y的最长公共子序
     列时，可能要计算出X和Yn-1及Xm-1和Y的最长公共子序列。而这两个子问题都包含一个公共子问题，
     即计算Xm-1和Yn-1的最长公共子序列。
     用c[i,j]记录序列Xi和Yj的最长公共子序列的长度。其中Xi=<x1, x2, …, xi>，Yj=<y1, y2, …, yj>。
     b[i,j]记录指示c[i,j]的值是由哪一个子问题的解达到的，这在构造最长公共子序列时要用到。
     
  - 构造最长公共子序列
       
       根据b的内容打印出Xi与Yj的最长公共子序列。如果b[i,j]里的值是↖则打印序列X的第i个元素。